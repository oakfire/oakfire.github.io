<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <title>clrs - ppt</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme" />
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->  
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
# 算法导论笔记
这是阅读算法导论的笔记

Created by [yongjiu.wei](mailto:oakfire@163.com)
          </script>       
        </section>

        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第2章 算法基础
* 插入排序(INSERT-SORT)与循环不变式
* 证明循环不变式三个性质:
  * **初始化**:第一次迭代前, 为真;
  * **保持**:本次为真,那么下次迭代也为真;
  * **终止**:迭代终止时，不变式提供一个有助于证明算法正确的性质． 
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###2.2分析算法
* 最坏情况与平均情况,插入排序 $O(n2)$
* 通常只关注最坏情况
* 增长量级 $O(n)$,$O(lgn)$...
            </script>
          </section> 

          <section data-markdown>
            <script type="text/template">

###2.3设计算法

* 分治法.三步骤:
  * **分解**原问题为若干规模较小的同子问题;
  * **解决**:递归地求解子问题.子问题规模足够小时直接求解;
  * **合并**子问题成原问题的解.
* 归并排序(MERGE-SORT)  $O(nlgn)$ 
* 思考题: 冒泡排序(BUBBLE-SORT);逆序对数量与插入排序的关系
            </script>
          </section>

        </section>
        
        
        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第3章 函数的增长
* 定义
  * $\Theta$记号:表示函数渐进紧确上下界
  * $Ο$记号:渐进上界,包括渐进确界,与 非渐进确界
  * $\Omega$记号:渐进下界
  * $ο$记号与$\omega$记号: 只包括非渐进确界.
* 性质: 传递性.自反性.对称性,转置对称性; 不满足三分性
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###3.2 常用函数
todo: LETEX 

数学函数的符号表示

**单调性**, **向下取整与向上取整**, **模运算**

**多项式**, **指数**, **对数**, **阶乘**, **多重函数**

**多重对数函数**,**斐波那契数**,**黄金分割率**

思考题:3-3 根据渐进增长率排序
            </script>
          </section>

        </section>

        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第4章 分治策略

* 分治策略算法的运行时间要求解**递归式**

* **递归式**(recurrence)是一个等式或不等式,通过函数更小输入上的值来描述本身

* 本章介绍三种求解递归式的方法,即$Ο$或$\Theta$的渐进界:
  * **代入法**　　数学归纳法证明猜测边界
  * **递归树法**　构建代价树,寻求效率边界
  * **主方法**　　可求解$T(n)=aT(n/b) + f(n)$其中$a>=1,b>1,f(n)$是给定的函数
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###4.1 最大子数组(maximum subarray)问题

* 寻找整数数组的和最大的非空连续子数组
* 数组[low,high]取中点为mid,问题可分解为以下三值的最大者
  * [low,mid]子问题的解
  * [mid,high]子问题的解
  * 跨越mid的最大子数组,线性时间

            </script>
          </section>

          <section>
              <ul><li>分治解运行时间$T(n)$的递归式:</li></ul>


$$
  T(n) = \left\{ 
   \begin{array}{l l}
       \Theta(1) & \quad \text{if $n = 1$ }\\
       2T(n/2)+\Theta(n) & \quad \text{if $n>1$}
             \end{array} \right.
$$
          </section>

          <section data-markdown>
            <script type="text/template">

* 习题4.1-5:最大子数组问题的线性时间解: [Kanade 算法](http://en.wikipedia.org/wiki/Maximum_subarray_problem)
  * 启发式. 扫描逐个求和,在和小于0时抛弃从当前值重算.
  * 这期间和的最大值即为最大子串 
  * 可证:已知最大子串[x,y],那么$0\eqslantless i<x$, [i,x]必为负,[x,j]必为正
  * 启发式是按照问题解的性质直接求得,记住方式就好.
  * python 代码表达:
    ```
def max_subarray(A):
    max_ending_here = max_so_far = 0
    for x in A:
        max_ending_here = max(0, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
    ```
            </script>
          </section>

          <section>
            <h3>4.2 矩阵乘法的 Strassen 算法</h3>
            <ul>
                <li>若 $A=(a_{ij}),  B=(b_{ij})$ 是 $n*n$的方阵,则对$i,j=1,2,...,n$,定义乘积$C=A\centerdot B$中的元素$c_{ij}$为:</li>
                $$ c_{ij} = \sum_{k=1}^n a_{ik} \centerdot b_{kj} $$
                <li>SQUARE-MATRIX-MULTIPLY-RECURSIVE运行时间的递归式:</li>
               
$$
  T(n) = \left\{ 
   \begin{array}{l l}
       \Theta(1) & \quad \text{if $n = 1$ }\\
       8T(n/2)+\Theta(n^2) & \quad \text{if $n>1$}
             \end{array} \right.
$$

            </ul>

          </section>

          <section>
            <ul>
                <li>Strassen 算法:核心思想是令递归数不那么茂盛
                <li>Strassen 运行时间的递归式:</li>
               
$$
  T(n) = \left\{ 
   \begin{array}{l l}
       \Theta(1) & \quad \text{if $n = 1$ }\\
       7T(n/2)+\Theta(n^2) & \quad \text{if $n>1$}
             \end{array} \right.
$$

            </ul>


          </section>

          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>
          
          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>

        </section>



        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>

        </section>

      </div>
    </div>
    
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
      Reveal.initialize({
        history: true,
        
        transition: 'slide',

        dependencies:[
          { src: 'js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'js/plugin/math/math.js', async: true }
        ]
      });
    </script>
    <div  style="display: block; position: absolute; bottom: 35px; left: 35px;  z-index: 20;">
      <a href="./" style="display: inline-block; height: 34px; line-height: 34px; box-sizing: border-box; border: 1px solid #AAA; color: #AAA; text-decoration:none; text-transform: uppercase; padding:0 5px; ">go to ppt index</a>
    </div>
  </body>
