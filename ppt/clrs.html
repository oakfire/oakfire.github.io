<!doctype html>
<html>
  <head>
    <meta charset="utf-8">

    <title>clrs - ppt</title>

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme" />
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->  
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown>
          <script type="text/template">
# 算法导论笔记
这是阅读算法导论的笔记

Created by [yongjiu.wei](mailto:oakfire@163.com)
          </script>       
        </section>

        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第2章 算法基础
* 插入排序(INSERT-SORT)与循环不变式
* 证明循环不变式三个性质:
  * **初始化**:第一次迭代前, 为真;
  * **保持**:本次为真,那么下次迭代也为真;
  * **终止**:迭代终止时，不变式提供一个有助于证明算法正确的性质． 
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###2.2分析算法
* 最坏情况与平均情况,插入排序 $O(n2)$
* 通常只关注最坏情况
* 增长量级 $O(n)$,$O(lgn)$...
            </script>
          </section> 

          <section data-markdown>
            <script type="text/template">

###2.3设计算法

* 分治法.三步骤:
  * **分解**原问题为若干规模较小的同子问题;
  * **解决**:递归地求解子问题.子问题规模足够小时直接求解;
  * **合并**子问题成原问题的解.
* 归并排序(MERGE-SORT)  $O(nlgn)$ 
* 思考题: 冒泡排序(BUBBLE-SORT);逆序对数量与插入排序的关系
            </script>
          </section>

        </section>
        
        
        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第3章 函数的增长
* 定义
  * $\Theta$记号:表示函数渐进紧确上下界
  * $Ο$记号:渐进上界,包括渐进确界,与 非渐进确界
  * $\Omega$记号:渐进下界
  * $ο$记号与$\omega$记号: 只包括非渐进确界.
* 性质: 传递性.自反性.对称性,转置对称性; 不满足三分性
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###3.2 常用函数
todo: LETEX 

数学函数的符号表示

**单调性**, **向下取整与向上取整**, **模运算**

**多项式**, **指数**, **对数**, **阶乘**, **多重函数**

**多重对数函数**,**斐波那契数**,**黄金分割率**

思考题:3-3 根据渐进增长率排序
            </script>
          </section>

        </section>

        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第4章 分治策略

* 分治策略算法的运行时间要求解**递归式**

* **递归式**(recurrence)是一个等式或不等式,通过函数更小输入上的值来描述本身

* 本章介绍三种求解递归式的方法,即$Ο$或$\Theta$的渐进界:
  * **代入法**　　数学归纳法证明猜测边界
  * **递归树法**　构建代价树,寻求效率边界
  * **主方法**　　可求解$T(n)=aT(n/b) + f(n)$其中$a>=1,b>1,f(n)$是给定的函数
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###4.1 最大子数组(maximum subarray)问题

* 寻找整数数组的和最大的非空连续子数组
* 数组[low,high]取中点为mid,问题可分解为以下三值的最大者
  * [low,mid]子问题的解
  * [mid,high]子问题的解
  * 跨越mid的最大子数组,线性时间
* 分治解运行时间$T(n)$的递归式:
$$
T(n) = \\left\\{ 
\\begin{array}{l l}
\\Theta(1) & \\quad \\text{if $n = 1$ }\\\\
2T(n/2)+\\Theta(n) & \\quad \\text{if $n>1$}
\\end{array} \\right.
$$
           </script>
          </section>

          <section data-markdown>
            <script type="text/template">

* 习题4.1-5:最大子数组问题的线性时间解: [Kanade 算法](http://en.wikipedia.org/wiki/Maximum_subarray_problem)
  * 启发式. 扫描逐个求和,在和小于0时抛弃从当前值重算.
  * 这期间和的最大值即为最大子串 
  * 可证:已知最大子串 [x,y], 那么 $0\eqslantless i<x$, [i,x] 必为负, [x,j] 必为正
  * 启发式是按照问题解的性质直接求得,记住方式就好.
  * python 代码表达:
    ```
def max_subarray(A):
    max_ending_here = max_so_far = 0
    for x in A:
        max_ending_here = max(0, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    return max_so_far
    ```
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###4.2 矩阵乘法的 Strassen 算法
        
* 若 $A=(a\_{ij}),  B=(b\_{ij})$ 是 $n*n$ 的方阵,则对 $i,j=1,2,...,n $, 定义乘积 $ C=A\centerdot B $ 中的元素 $c\_{ij}$ 为:

$$ c\_{ij} = \\sum\_{k=1}^n a\_{ik} \\centerdot b\_{kj} $$

* SQUARE-MATRIX-MULTIPLY-RECURSIVE 运行时间的递归式:
               
$$
T(n) = \\left\\{ 
\\begin{array}{l l}
\\Theta(1) & \\quad \\text{if $n = 1$ }\\\\
8T(n/2)+\\Theta(n^2) & \\quad \\text{if $n>1$}
\\end{array} \\right.
$$

            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
* Strassen 算法:核心思想是令递归数不那么茂盛
* Strassen 运行时间的递归式:

$$
T(n) = \\left\\{ 
\\begin{array}{l l}
\\Theta(1) & \\quad \\text{if $n = 1$ }\\\\
7T(n/2)+\\Theta(n^2) & \\quad \\text{if $n>1$}
\\end{array} \\right.
$$
              
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
###4.3 用代入法求解递归式
* 分为两步:
  1. 猜测解的形式.
  2. 用数学归纳法求出解的常数,并证明解为正确.
* 做出好猜测,启发式,避免陷阱,改变变量

###4.4 用递归树方法求解递归式
* 递归数适合用来生成好的猜测
            </script>
          </section>
          
          <section data-markdown>
            <script type="text/template">
###4.5 用主方法求解递归式
* 主定理:定理4.1 令 $a\\geqslant 1$ 和 $b>1$ 是常数, $f(n)$是一个函数, $T(n)$是定义在非负整数上的递归式:
$$ T(n)=aT(n/b)+f(n)$$其中将 $n/b$ 解释为 $\\lfloor n/b \\rfloor$ 或 $\\lceil n/b \\rceil$. 那么 $T(n)$ 有如下渐进界:
  1. 若对某常数 $\\varepsilon >0$ 有 $f(n)=O(n^{log_ba -\\varepsilon})$, 则 $ T(n)=\\Theta(n^{log_ba})$
  2. 若 $f(n)=\\Theta(n^{log_ba})$, 则 $T(n)=\\Theta(n^{log_ba}lgn)$
  3. 若对某常数 $\\varepsilon>0$, 有 $f(n)=O(n^{log_ba +\\varepsilon})$, 且对某常数 $c<1$ 和所有足够大的 $n$ 有 $af(n/b)\\leqslant cf(n)$, 则 $T(n)=\\Theta(f(n))$
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
* 使用主方法:
  * 最大子数组和归并排序的分治算法递归式 $T(n)=2T(n/2) + \\Theta(n)$,  有 $a=2, b=2, f(n) = \\Theta(n)$, 因此有 $n^{log_ba}=n^{log_2 2} = n$. 由于 $f(n)=\\Theta(n)$, 应用情况2, 于是得到解 $T(n)=\\Theta(nlgn)$ 
  * 矩阵乘法普通分治算法递归式 $T(n)=8T(n/2)+\\Theta(n^2)$ , 应用情况1, 得出解 $T(n)=\\Theta(n^3)$
  * 矩阵乘法 Strassen 算法递归式 $T(n)=7T(n/2)+\\Theta(n^2)$, 同情况1, 得出解 $T(n)=\\Theta(n^{lg7})$
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
* 主方法易用, 但只能应用于子问题规模相等的情况.
* 子问题划分不均衡的算法的递归式, 可用 Akra-Bazzi 方法求解.详见书中的记注(p62)(ep110)

            </script>
          </section>

        </section>

  <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##第5章 概率分析和随机算法
###5.1 雇用问题 HIRE-ASSISTANT
* **平均情况运行时间**:对所有可能输入产生的运行时间取平均
* **期望运行时间:随机算法的运行时间
###5.2 指示器随机变量(indicator random variable)
* 定义: 给定一个样本空间 $S$ 和一个事件 $A$, $$ I\\{A\\} = \\begin{cases} 1 & \\quad \\text{如果 $A$ 发生}\\\\ 0 & \\quad \\text{如果 $A$ 不发生} \\end{cases} $$
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>

        </section>



        <!-- *************************************************-->
        <section>

          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>

          <section data-markdown>
            <script type="text/template">
##测试代码块
            </script>
          </section>

        </section>

      </div>
    </div>
    
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>
    <script>
      Reveal.initialize({
        history: true,
        
        transition: 'slide',

        dependencies:[
          { src: 'js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
          // mathjax 与 markdown 混用时, 要注意:
          // 1. markdown的'\'有转意, 比如'\\'与'\{',表示'\'与'{'.所以安全起见,
          //    可以把mathjax所有的'\'都在markdown里写为'\\'
          // 2. markdown的'_'有斜体涵义, mathjax公式下标用到时, 需要转义为'\_'
          ,{ src: 'js/plugin/math/math.js', async: true }
        ]
      });
    </script>
    <div  style="display: block; position: absolute; bottom: 35px; left: 35px;  z-index: 20;">
      <a href="./" style="display: inline-block; height: 34px; line-height: 34px; box-sizing: border-box; border: 1px solid #AAA; color: #AAA; text-decoration:none; text-transform: uppercase; padding:0 5px; ">go to ppt index</a>
    </div>
  </body>
